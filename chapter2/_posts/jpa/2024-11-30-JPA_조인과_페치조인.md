# JPA 조인과 페치조인
### 조인전략

- 조인 전략은 엔티티 각각을 **모두 테이블로 만들고** 자식 테이블이 부모 테이블의 기본 키를 받아서 **기본 키 + 외래 키**로 사용하는 전략이다. 따라서 조회할 때 `조인`을 자주 사용한다
- `@Inheritance(stategy = inheritanceType.JOINED)`  : 상속 매핑은 부모 클래스에 @Inheritance를 사용해야한다.
- `@DiscriminatorColumn(name = "DTYPE")` : 부모 클래스에 구분 칼럼을 지정한다. 이 칼럼으로 저장된 자식 테이블을 구분할 수 있다. 기본값이 `DTYPE` 이다. 하이버네이트에서는 구분 컬럼 없이도 동작한다
- `@DiscriminatorValue("M")` : 엔티티르 저장할 때 구분 컬럼에 입력할 값을 지정한다
- `@PrimaryKeyJoinColumn` : 자식 테이블은 부모 테이블 ID 컬럼명을 그래도 사용하는데 만약 자식 테이블의 기본 키 컬럼명을 변경하고 싶을 때 사용한다

### 식별 관계 vs 비식별 관계

- 식별관계는 부모 테이블의 기본 키를 내려받아서 자식 테이블의 **기본 키 + 외래 키**로 사용하는 관계이다
- 비식별 관계는 부모 테이블의 기본 키를 받아서 외래 키로만 사용하는 관계이다
- 요즘은 **비식별 관계를 주로 사용**하고, 꼭 필요한 경우에만 식별 관계를 사용하는 추세

### 조인 테이블

- 데이터베이스 테이블의 연관관계를 설계하는 방법은 크게 2가지다
    - **조인 컬럼 사용(외래 키)**
        - **외래 키 컬럼**을 사용해서 관리한다
        - 하지만 외래 키가 없는 경우가 생길 수 있기 때문에 외래 키에 `null`값을 허용 해야한다. 이를 선택적 비식별 관계라 한다
        - 이로 인해 `OUTER JOIN` 이 발생하며 조회 시 성능이 떨어질 수 밖에 없다
    - **조인 테이블 사용(테이블 사용)**
        - 연관관계를 관리하는 `조인 테이블`을 추가하고 여기서 두 테이블의 `외래 키`를 가지고 연관관계를 관리한다. 따라서 원래 테이블에는 `외래 키` 컬럼이 없다
        - *단점은 테이블이 늘어나며 조인이 늘어난다는 단점이 있다*

## 프록시

- `프록시`는 연관된 객체를 **처음**부터 데이터베이스에서 조회하는 것이 아니라, **실제 사용하는 시점에 데이터베이스에서 조회할 수 있다.** 하지만 자주 함께 사용하는 객체들은 `조인`을 사용해서 **함께 조회하는 것이 효과적**이다
- **지연 로딩** : **실제 사용**될 때까지 데이터베이스 조회를 지연하는 방법

    ```java
    @ManyToOne(fetch = FetchType.LAZY)
    ```

- **즉시 로딩 :** 엔티티를 조회할 때 연관된 엔티티도 함께 조회한다

    ```java
    @ManyToOne(fetch = FetchType.EAGER)
    ```

    - 즉시 로딩을 최적화하기 위해 가능하면 **조인 쿼리를 사용**한다

### JPA 조인 전략

- JPA는 선택적 관계면 외부 조인을 사용하고 필수 관계면 내부 조인을 사용한다.
- `외부조인` 보단 `내부조인`이 **성능과 최적화에서 유리**하므로 외래 키에 `NOT NULL` 제약을 설정하여 값이 있는 것을 보장하여 **내부 조인**만 **사용하게끔 유도해야한다**
- `nullable = false` 설정을 통해 JPA 알려주면 외부 조인 대신에 내부 조인을 사용한다

    ```java
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinCloum(name = "test", nullable = false) // not null 설정, 내부 조인 사용
    
    @ManyToOne(fetch = FetchType.EAGER, optional = false) // 똑같이 내부 조인 사용
    @JoinCloum(name = "test") 
    ```


### 프록시 객체

- 지연 로딩 기능을 사용하려면 실제 엔티티 객체 대신에 데이터베이스 조회를 지연할 수 있는 **가짜 객체**가 필요한데 이것이 `프록시 객체`이다
- `엔티티`를 실제 사용하는 시점까지 데이터베이스 조회를 미루고 싶으면 `EntityManager.getReference()` 메소드를 사용하면 된다. 이 메소드를 호출할 때 JPA는 **데이터베이스를 조회하지 않고 실제 엔티티 객체도 생성하지 않는다**.
- 프록시 객체는 실제 객체에 대한 `참조(target)`을 보관한다. 그리고 프록시 객체의 메소드를 호출하면 프록시 객체는 **실제 객체의 메소드를 호출**한**다**
- **프록시 객체의 초기화 :** 메소드가 실제 사용될 때 데이터베이스를 조회해서 실제 인테테 객체를 생성하는데 **이것을 프록시 객체의 초기화라 한다**
- 프록시 객체는 처음 사용할 때 **한 번만 초기화** 된다
    - 프록시 객체가 초기화한다고 프록시 객체가 실제 엔티티로 바뀌는것이 아니라 프록시 객체를 통해서 **실제 엔티티에 접근할 수 있는 것**이다
- `영속성 컨텍스트`에 찾는 엔티티가 이미 있으면 *데이터베이스를 조회할 필요가 없으므로* `em.getReference()`를 호출해도 프록시가 아닌 실제 엔티티를 반환한다
- 초기화는 `영속성 컨텍스트`의 도움을 받아야 하므로 준영속 상태는 초기화를 할 수 없다

### JPA 기본 페치 전략

- **컬렉션 래퍼** : 하이버네이트는 엔티티를 `영속 상태`로 만들 때 엔티티에 컬렉션이 있으면 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 **하이버네이트가 제공하는 내장 컬렉션으로 변경**하는데 이럴 `컬렉션 래퍼`라 한다
    - 컬렉션 타입의 값들은 `컬렉션 래퍼`가 지연 로딩을 처리한다
    - 컬렉션 래퍼는 member.getOrders()를 *호출해도 초기화 되지 않는다.* member.getOrders().get(0) 같이 `실제 데이터`를 조회할 때 **데이터베이스를 조회해서 초기화한다**
- **@ManyToOne, @OneToOne** : 즉시 로딩
- **@OneToMany, @ManyToMany** : 지연 로딩
    - 컬렉션을 로딩하는 것은 비용이 많이 들고 잘못하면 **너무 많은 데이터를 로딩할 수 있기 때문**이다
- 성능과 최적화를 위해서는 **모든 연관관계에 `지연 로딩`을 사용하는 것이다.** 그리고 **꼭 필요한 곳**에만 `즉시 로딩`을 사용하게 최적화 하는 것이 좋다